# Спецификация разработки ПО	
## Содержание
1. [Введение](#1) 
  1.1 [Цель](#1.1)
  1.2 [Обзор системы](#1.2)
2. [Используемые технологии](#2) 
  2.1. [C11](#2.1) 
  2.2. [GNU Make](#2.2) 
  2.3. [gcc](#2.3) 
  2.4. [GNU Readline](#2.4) 
3. [Архитектура](#3) 
  3.1. [Обзор](#3.1) 
  3.2. [Режимы работы](#3.2) 
  3.3. [Инициализация](#3.3) 
  3.4. [Язык оболочки](#3.4) 
  3.5. [Выполнение команд](#3.5) 
     3.5.1. [Встроенные команды](#3.5.2)
## 1. Введение <a name="1"></a>
### 1.1 Цель <a name="1.1"></a>
Целью создания данной спецификации является описание архитектуры и функционала командной оболочки "smsh".
### 1.2 Обзор системы <a name="1.2"></a>
"smsh" является интерпретатором команд пользователя, предоставляющим интерфейс для взаимодействия с операционной системой, и поддерживает простой самостоятельный язык программирования с собственным синтаксисом и отличительными функциональными возможностями.
## 2. Используемые технологии <a name="2"></a>
### 2.1 C11 <a name="2.1"></a>
Язык C является основным языком программирования при разработке данной командной оболочки. В качестве стандарта языка C принят C11. 
### 2.2 GNU Make <a name="2.2"></a>
В качестве системы сборки используется утилита Make, которая является достаточно удобным инструментом для проектов небольшого размера. Используется версия GNU Make 3.75.
### 2.3 gcc <a name="2.3"></a>
Компилятор gcc является самым распространенным и наиболее мощным компилятором C под Linux, поэтому был выбран для разработки. Используется версия gcc 8.4.
### 2.4 GNU Readline <a name="2.4"></a>
Библиотека GNU Readline предоставляет набор функций для  чтения и редактирования ввода пользователя. Доступны режимы редактирования Emacs и vi. Используется версия GNU Readline 8.1.
## 3. Архитектура <a name="3"></a>
### 3.1 Обзор <a name="3.1"></a>
Разрабатываемая командная оболочка предоставляет пользователю стандартный функционал: запуск исполняемых файлов, перенаправление стандартных потоков ввода/вывода, создание каналов, контроль задач (job control), выполнение встроенных и составных команд, создание переменных и вычисление арифметических выражений. Особенности архитектуры создаваемой командной оболочки обусловлены процедурной парадигмой разработки. На рисунке представлена диаграмма вариантов использования.
![img](https://github.com/3axapMaiceenka/smsh/blob/main/doc/UseCase.png) <br>
### 3.2 Режимы работы <a name="3.2"></a>
Командная оболочка поддерживает два режима работы: интерактивный и неинтерактивный. В интерактивном режиме работы оболочка считывает ввод пользователя и выполняет заданные команды. В неинтерактивном режиме оболочка читает и выполняет команды из файла, имя которого передается в качестве аргумента командной строки.
### 3.3 Инициализация <a name="3.3"></a>
При инициализации (запуске) оболочкой выполняется следующее:
* Оболочка ожидает, пока не будет выполняться в обычном режиме работы (foreground mode):
``` c
while ((shell->pgid = getpgrp()) != tcgetpgrp(STDIN_FILENO)) 
{
	kill(-shell->pgid, SIGTTIN);
}
```
* Командная оболочка должна игнорировать некоторые сигналы ОС:
``` c
signal(SIGINT, SIG_IGN);
signal(SIGQUIT, SIG_IGN);
signal(SIGTSTP, SIG_IGN);
signal(SIGTTIN, SIG_IGN);
signal(SIGTTOU, SIG_IGN);
```
* Оболочка помещает себя в собственную группу процессов и "берет контроль" над терминалом:
``` c
shell->pgid = getpid();
setpgid(shell->pgid, shell->pgid);
tcsetpgrp(STDIN_FILENO, shell->pgid);
```
 Все вышеперечисленные действия выполняются для того, чтобы командная оболочка могла осуществлять контроль задач (job control). Также командная оболочка считывает и сохраняет переменные среды и их значения. 
### 3.4 Язык оболочки<a name="3.4"></a>
Полная спецификация синтаксиса языка командной оболочки приведена [здесь](https://github.com/3axapMaiceenka/smsh/blob/main/doc/grammar.txt).  Используется нисходящий рекурсивный метод парсинга. Далее приводятся примеры команд, которые выполняет "smsh":
* Запуск исполняемого файла
```
command_name arg1 arg2 >out.txt <in.txt
```
`command_name` - имя исполняемого файла
`arg1 arg2` - переданные аргументы
`>out.txt` - перенаправление стандартного потока вывода в файл out.txt
`<in.txt` - перенаправление стандартного потока ввода в файл in.txt 
* Создание канала
```
cmd1 | cmd2 | cmd3
```
` cmd1 cmd2 cmd3` - процессы для запуска, соединяемые между собой через каналы
* Создание переменных
```
var1="abcd"
var2=$var1
var3=$((2 + 2))
var4=$(($var3 * (4 - 1)))
```
Специальный символ `$` используется для получения значения переменной. Конструкция `$((...))`содержит арифметическое выражение.
* Конструкция if/else
```
if cmd_name1
then
	cmd_name2
else
	cmd_name3
fi
```
Код возврата процесса `cmd_name1` используется в качестве условия.
* Цикл for
```
for i in a b 1 $((1 + 1)) $var
do
	echo $i
done
```
Переменная `i` получает значения из списка  `a b 1 $((1 + 1)) $var`.
* Цикл while
```
while cmd1
do
	cmd2
done
```
Код возврата команды `cmd1` используется в качестве условия цикла.
### 3.5 Выполнение команд<a name="3.5"></a>
На рисунке приведена диаграмма активностей:
![img](https://github.com/3axapMaiceenka/smsh/blob/main/doc/ActivityDiagram.png)
#### 3.5.1 Встроенные команды <a name="3.5.1"></a>
Командная оболочка предоставляет реализацию некоторых команд, которые называются встроенными и влияют на состояние оболочки, в виде функций: 
* `cd` - смена текущей директории
* `export` - создание новой переменной окружения
* `unset` - удаление переменной окружения
* `bg` - перевод последней запущенной задачи в фоновый режим
* `fg` - перевод последней запущенной задачи в обычный режим (foreground mode)